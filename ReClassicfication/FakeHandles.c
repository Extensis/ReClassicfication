/*	°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°	PROJECT:	FakeHandles		FILE:		FakeHandles.c		PURPOSE:	Simulate Handles on machines which only have ANSI-C to easily				port some of the more simple Macintosh code fragments to other				platforms.			COPYRIGHT:	(C) Copyright 1998 by M. Uli Kusterer, all rights reserved.					REACH ME AT:				E-MAIL:		witness@weblayout.com				COMPUSERVE:	101646,3646 / custos				URL:		http://www.weblayout.com/witness			REVISIONS:		98-08-30	UK		Created.					°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°° */#pragma mark [Headers]/* ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	Headers:   ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ */#include	<stdlib.h>#include	<stdio.h>#include	<stdbool.h>#include	"FakeHandles.h"/* ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	Globals:   ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ */MasterPointer		masterPointers[MAX_HANDLE_COUNT];/* ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	InitFakeResources:		Call this to initialize the fake memory Manager at the start of your		program. Only call this once or you'll lose all your Handles and will have		stale memory lying around. Pass the global masterPointers in masterPtrArray.			REVISIONS:		98-08-30	UK		Created.   ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ */void	InitFakeHandles( MasterPointer* masterPtrArray ){	long		x;		for( x = 0; x < MAX_HANDLE_COUNT; x++ )	{		masterPtrArray[x].actualPointer = NULL;		masterPtrArray[x].used = false;		masterPtrArray[x].memoryFlags = 0;		masterPtrArray[x].size = 0;	}}/* ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	NewHandle:		Create a new Handle. This creates a new entry in the Master Ptr array and		allocates memory of the specified size for it. Then it returns a Ptr to		this entry.				Returns NULL if not successful. This may mean that there are no more		unused Master Ptrs or that we're out of memory.			REVISIONS:		98-08-30	UK		Created.   ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ */Handle	NewFakeHandle( long theSize ){	Handle		theHandle = NULL;	long		x;		for( x = 0; x < MAX_HANDLE_COUNT; x++ )	{		if( !(masterPointers[x].used) )		{			masterPointers[x].actualPointer = malloc( theSize );			if( ((long) masterPointers[x].actualPointer) > 0 )			{				masterPointers[x].used = true;				masterPointers[x].memoryFlags = 0;				masterPointers[x].size = theSize;								theHandle = (Handle) &(masterPointers[x]);				break;			}			else				break;		}	}		return theHandle;}/* ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	DisposeHandle:		Dispose an existing Handle. Only call this once or you might kill valid		memory or worse.				This frees the memory we use and marks the entry for the specified Handle		as unused.			REVISIONS:		98-08-30	UK		Created.   ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ */void	DisposeFakeHandle( Handle theHand ){	MasterPointer*		theEntry = (MasterPointer*) theHand;		free( theEntry->actualPointer );	theEntry->used = false;	theEntry->actualPointer = NULL;	theEntry->memoryFlags = 0;	theEntry->size = 0;}/* ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	GetHandleSize:		Return the size of an existing Handle. This simply examines the "size"		field of the Handle's entry.			REVISIONS:		98-08-30	UK		Created.   ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ */long	GetFakeHandleSize( Handle theHand ){	MasterPointer*		theEntry = (MasterPointer*) theHand;		return( theEntry->size );}/* ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	SetHandleSize:		Change the size of an existing Handle. This reallocates the Handle (keeping		its data) and updates the size field of the Handle's entry accordingly.			REVISIONS:		98-08-30	UK		Created.   ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ */void	SetFakeHandleSize( Handle theHand, long theSize ){	MasterPointer*		theEntry = (MasterPointer*) theHand;	char*				thePtr;		thePtr = theEntry->actualPointer;		thePtr = realloc( thePtr, theSize );		if( thePtr )	{		theEntry->actualPointer = thePtr;		theEntry->size = theSize;	}}